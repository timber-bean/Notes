[TOC]

# overload、override、overwrite

overload（重载）、override（覆盖）、overwrite（重写）的区别。

## overload

在C++程序中，可以将语义、功能相似的几个函数用同一个名字表示，但参数不同（包括数目、类型、顺序不同）。特征：

* 相同的范围（在同一个类中）；
* 函数名字相同；
* 参数（数目、类型、顺序）不同。

## override

是指派生类函数覆盖基类函数，特征是：

* 不同的范围（分别位于派生类与基类）；
* 函数名字相同；
* 参数相同；
* 基类函数必须有virtual关键字（虚函数）。

## overwrite

是指派生类的函数屏蔽了与其同名的基类函数，规则：

* 如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏。

* 如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。

# const

## 定义常量

const+对象类型即可。常量定义必须初始化。

* 对于局部对象，常量存放在**栈区**；
* 对于全局对象，常量存放在**全局/静态存储区**；
* 对于字面值常量，常量存放于常量存储区。

## 修饰指针变量

* const修饰指针指向的内容，则内容为不可变量；
* const修饰指针，则指针为不可变量；
* const修饰指针和指针指向的内容，则二者皆为不可变量。

```C++
const int *p = 8; //修饰指向的内容

int a = 8;
int* const p = &a; // 修饰指针

int a = 8;
const int * const p = &a; //既修饰指针，也修饰内容
```

## 修饰函数参数传递

* 值传递的const修饰，一般不需要，因为函数会自动产生临时变量复制实参值；
* 指针传递的const修饰，可防止指针被意外修改；
* 自定义类型的参数传递，需要临时对象复制参数，对于临时对象的构造，需要调用构造函数，比较浪费时间，因此我们采取 const 外加引用传递的方法。

## 修饰函数返回值

* const修饰内置类型的返回值，修饰与不修饰返回值作用一样。
* const修饰自定义类型的作为返回值，此时返回的值不能作为左值使用，既不能被赋值，也不能被修改。
* const修饰返回的指针或者引用，是否返回一个指向 const 的指针，取决于我们想让用户干什么。

## 修饰类成员函数

防止成员函数修改被调用对象的值。所有成员函数都应当声明为const成员函数。

# struct和class

C++中，struct和class都可以定义类，且都可以继承。

区别：struct的默认访问权限和默认继承权限为public，而class的默认访问权限和默认继承权限为private。

此外，class还可以定义模板类形参，如template <class AnyType>。

# 四种类型转换

* const_cast：用于将const变量变为非const变量。
* static_cast：用于各种**隐式转换**，比如基础数据类型的转换、**同一个继承体系**中的类型转换以及任意类型与空指针类型void*之间的转换。
* dynamic_cast：用于**动态类型转换**。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的，对于指针返回NULL，对于引用抛异常。
  * 向上转换：子类向基类的转换；
  * 向下转换：基类向子类的转换。它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。 
* reinterpret_ cast：几乎什么都可以转，但不做任何保证。不能将指针转为更小的整型或浮点型，不能将函数指针与数据指针互相转换。
* 为什么不用C的强制转换？C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。

