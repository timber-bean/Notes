[TOC]

# C++简史

## 面向对象编程

### 定义

Object Oriented Programming 强调数据。

它不像过程性编程那样，试图使问题满足语言的过程性方法，而是**试图让语言满足问题的要求**。

理念是**设计与问题的本质特性相对应的数据格式**。

### 设计方法

自下而上的编程。

首先，设计**类**，使它们准确地表示程序要处理的东西。包括数据和方法。

其次，设计使用这些类的对象的程序。

### 优势

有助于重用和修改现在的、经过仔细测试的代码。

**多态**能够为运算符和函数创建多个定义，通过编程上下文来确定使用哪个定义。

**继承**能够使用旧类派生出新类。

## 泛型编程

Generic Programming 与OOP目标相同，使重用代码和抽象通用概念的技术更简单。

OOP强调的是编程的数据方面，而GP强调的是**独立于特定数据类型**。

## 程序的一生

源代码 --> 编译器编译 --> 目标代码 --> 启动代码&库代码 --> 链接程序 --> 可执行代码

## 与C语言的区别

**设计思想**：C++是面向对象的语言；而C语言是面向过程的语言。

**语法上**：C++具有重载、继承、多态三种特性；C++增加了类型安全的功能，例如强制类型转换；C++支持范式编程，例如模板类、函数模板等。

## C++11的新特性



# 内存结构

![memory1](F:\Notes\C plus plus\pic\memory1.png)

# 存储方式

C++11中，共有四种存储方式，分别是，自动存储、静态存储、线程存储和动态存储。

## 自动存储

定义：在函数中声明的变量（包括函数参数）。

持续性：自动。它们在程序开始执行其所属的函数及代码块时被创建，在执行完函数或代码块时，内存被释放。

作用域：包含它的函数或代码块。

存在位置：栈。

链接性：无，不能被共享。

## 静态存储

定义：在函数定义外定义的变量；使用关键字static定义的变量。

持续性：在程序整个运行过程中都存在。

作用域：与定义的位置有关。

存在位置：静态变量区。

### 链接性

#### 外部链接性

可在其他文件中访问。

**定义方式**：在代码块外声明，且不加static。

**使用方式**：**单定义，多声明**。仅在一个文件中定义该变量，其他文件使用时，需要使用extern声明。

#### 内部链接性

只能在当前文件中访问。

**定义方式**：在代码块外声明，且加static。

#### 无链接性

只能在当前函数或代码块中访问。

**定义方式**：在代码块内声明，且加static。

## 动态存储

定义：使用new运算符分配的数据。

持续性：动态。一直存在，直到使用delete运算符将其释放或者程序终止。

作用域：受new和delete的控制，有可能是单一文件，也有可能是多个文件。

存在位置：堆。

会导致的问题：堆泄露。原因：在new以后，没有调用delete。解决方法：new和delete配套使用；**C++智能指针**。

## 线程存储

定义：使用thread_local声明的变量。

持续性：和所属线程的生命周期一样长。

## 总结

|    存储描述    | 持续性 | 作用域 | 链接性 |          声明方式          |
| :------------: | :----: | :----: | :----: | :------------------------: |
|    自动存储    |  自动  | 代码块 |   无   |         在代码块中         |
|   寄存器存储   |  自动  | 代码块 |   无   |  在代码块中，使用register  |
|  静态，无链接  |  静态  | 代码块 |   无   |   在代码块中，使用static   |
| 静态，内部链接 |  静态  |  文件  |  内部  | 不在任何函数中，使用static |
| 静态，外部链接 |  静态  |  文件  |  外部  |       不在任何函数中       |

# 内联函数

## 与常规函数的区别

主要区别在于C++编译器如何将它们组合到程序中。

**常规函数**：执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈中，跳到标记函数起点的内存单元，执行函数代码，然后跳回到地址被保存的指令处。

**内联函数**：内联函数的编译代码与其他程序代码“内联”起来，程序无需跳到另一个位置处执行代码，再跳回来。因此，内联函数运行速度更快，但是消耗内存更多。且内联函数不能**递归**。

## 使用

必须采取下述措施之一：

* 在函数声明前加关键字inline。

* 在函数定义前加关键字inline。

## 内联与宏

C语言使用预处理语句#define来提供宏——内联代码的原始实现。

**区别**：内联函数是按值传递参数，而宏只是进行文本替换。

# 友元

友元可以访问类的所有私有（private）成员和保护（protected）成员。友元的分类：

* 友元函数
* 友元类
* 友元成员函数

## 友元函数

友元函数的定义需要放在类声明中，并在原型声明前加关键字friend。友元函数虽在类中声明，但是友元函数不是类的成员函数。

```C++
class Box{
   double width;
public:
   friend void printWidth( Box box );
   void setWidth( double wid );
};

void Box::setWidth( double wid ){
    width = wid;
}
 
// printWidth() 不是任何类的成员函数
void printWidth( Box box ){
   cout << "Width of box : " << box.width <<endl;
}
```

由于友元函数不是成员函数，因此没有this指针，因此对参数的需求如下：

* 要访问非static成员时，需要对象做参数；
* 要访问static成员或全局变量时，则不需要对象做参数；
* 如果做参数的对象是全局对象，则不需要对象做参数。

## 友元类

它的出现是因为，存在两个类，它们之间无法通过公有继承或是保护继承、私有继承的方式完成任务。声明式，在类前加关键字friend即可，它可以位于公有、私有或者保护部分，无关紧要。

```C++
#ifndef TV_H_
#define TV_H_

class Tv{
public:
    friend class Remote; //友元类
    enum{Off, On};
    
    Tv(int s = Off, int vol = 50):state(s),volume(vol){}
    bool volup();
private:
    int state;
    int volume;
}
class Remote{
private:
    int mode;
public:
    Remote(int m = Tv::TV):mode(m){}
    bool volup(Tv & t){return t.volup();}
}
#endif
```

## 友元成员函数

它的出现，可以使得仅让特定的类成员成为另一个类的友元，而不必让整个类成为友元。

# 引用

引用是已定义变量的别名。

## 用途

用作函数的形参。通过将引用变量用作参数，函数将使用原始数据，而不是其副本，使其可以在函数中改变原始数据，如下述代码，效果一样。

```C++
void swapr(int &a, int &b){ //使用引用变量
    int temp;
    temp = a;
    a = b;
    b = temp;
}

void swapp(int *p, int *q){ //使用指针
    int temp;
    temp = *p;
    *p = *q;
    *q = temp;
}
```

引入引用，主要为了用于**结构**和**类**中。

## 引用与指针

### 区别

* 指针有自己的一块空间，引用只是一个别名；
* 使用sizeof看一个指针大小为4，引用则是被引用对象的大小；
* 指针可以被初始化为NULL，引用必须被初始化且必须是一个已有对象的引用；
* 有const指针，没有const引用；
* 指针在使用中可以指向其他对象，引用只能是一个对象的引用，**不能被改变**。
* 指针可以有多级指针，引用只有一级；
* 指针和引用使用++运算符的意义不一样；
* 返回动态内存分配的对象或者内存，必须用指针，引用可能会引起内存泄露。

### 传递引用与传递指针

* 声明函数参数的方式不同；
* 传递指针时，函数在使用p和q的整个过程中，需要使用解除引用运算符*。

# 多态

多态，是指有多种形式。C++中有静态多态（重载、模板）和动态多态（虚函数、基类的指针或引用指向派生类的对象）。

## 函数多态

函数多态（函数重载）能够让开发者使用多个同名函数。前提是它们的**特征标**（参数数目、类型、排列顺序）不同。

### 注意

* 应把类型引用和类型本身看作同一特征标。
* 函数类型的区别，不能成为函数多态的前提。

## 运算符重载

重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成。需要注意的是：

* 重载后的运算符必须至少有一个操作数是用户定义的类型。
* 重载的运算符可以是在**类外定义的普通函数，也可以是类的成员函数或友元函数**。最好是后两者。
* 大部分的运算符可以重载，**成员访问符”.”，成员指针访问运算符”.\*“，作用域运算符“::”，条件运算符”?:”，长度运算符“sizeof”**。
* 重载不改变操作对象的个数，即不能违反运算符原来的句法规则。
* 重载不改变运算符的优先级。

## 函数模板

是通用的函数描述，是使用泛型来定义函数。通过将类型作为函数参数传递给模板，可是编译器生成该类型的函数。如下代码建立了一个交换模板：

```C++
template <typename AnyType> //指出要建立一个模板，并将类型命名为AnyType。可以用class替代typename
void Swap(AnyType &a, AnyType &b){
    AnyType temp;
    temp = a;
    a = b;
    b = temp;
}
```

**重载**：被重载的模板函数，特征标必须不同。

# 类

## 类的工作

决定数据对象需要的内存空间。

决定如何解释内存中的位。

决定可使用数据对象执行的操作或方法。

## 定义类

类声明：以数据成员的方式描述数据部分，以成员函数的方式描述公有接口。

类方法定义：描述如何实现类成员函数。

## 访问控制

数据项通常放在私有部分，组成类接口的成员函数放在公有部分。也可使用私有成员函数来处理部署于公有接口的实现细节。

**与结构的区别**：结构的默认访问类型是public，而类的默认访问类型是private。

## 成员函数

### 特征

定义成员函数时，使用作用域解析运算符（::）来标识函数所属的类。

类方法可以访问类的private组件。

### 内联

定义位于类声明中的函数自动成为内联函数。

也可以在类声明之外定义成员函数，并使其成为内联函数。只需在类实现部分中定义函数时使用inline限定符即可。

## 构造函数

专门用于构造新对象、将值赋给它们的数据成员。该函数的名称与类名相同。且没有返回值，也没有声明类型。

### 默认构造函数

在未提供显式初始值时，用来创建对象的构造函数。默认构造函数**没有参数**。

如果程序员没有定义构造函数，编译器会为程序定义一个默认构造函数。否则，程序员需要自行定义。

方式：一种是给已有构造函数的所有参数提供默认值；另一种是通过函数重载来定义另一个构造函数——没有参数的构造函数。

## 析构函数

当对象“过期”时，程序将自动调用析构函数完成清理工作。（注：如果构造中没有使用new，则析构函数没有实际需要完成的任务。）析构函数同样没有返回值和声明类型，与构造函数不同的是，析构函数没有参数。

```C++
class Stock{
    private:
    	string company_;
    	int price_;
    public:
    	Stock(); //默认构造函数
    	Stock(const & string company, int price); //参数名不能与类成员相同
    	~Stock();
}
Stock::Stock(){ //默认构造函数（通过函数重载实现）
    company_ = "no name";
    price_ = 0;
}
Stock::Stock(const & string company, int price){
    company_ = company;
    price_ = price;
}
Stock::~Stock(){ //析构函数
}
```

## this指针

在 C++ 中，每一个对象都能通过this指针来访问自己的地址。this指针是所有成员函数的隐含参数。因此，每个类成员函数，都有this指针，它可以用来指向调用对象。

```C++
const Stock & Stock::topval(const Stock & s) const{
    if(s.total_val>total_val) return s;
    else return *this; //这里返回的是*this，即对象本身，而this是对象的地址
}
```

## 对象数组

要创建类对象数组，这个类必须有默认构造函数。步骤如下：

* 使用默认构造函数创建数组元素；
* 花括号中的构造函数将创建临时对象；
* 将临时对象的内容复制到相应的元素中。

## 指向类的指针

一个指向 C++ 类的指针与指向结构的指针类似，访问指向类的指针的成员，需要使用成员访问运算符 **->**，就像访问指向结构的指针一样。必须在使用指针之前，对指针进行初始化。

# 继承

类继承能够从已有的类派生出新的类，而派生类继承了原有类的特征，包括方法。类继承可以允许开发者只提供新特性，甚至不需要访问源代码就可以派生出类。类继承分为三类，公有继承、保护继承以及私有继承。

## 公有继承

公有继承中，基类的公有成员将成为派生类的公有成员；基类的私有部分也将成为派生类的一部分，不过只能通过**基类的公有和保护方法**访问。公有继承使用冒号+关键字public声明。

```C++
class RatedPlayer : public TableTennisplayer{
private:
    int rating;
public:
    RatedPlayer(unsigned int r = 0, const string  & fn = "none", const string  & ln = "none");
    RatedPlayer(unsigned int r, const TableTennisplayer(fn, ln)); //使用TableTennisplayer参数
};
//TableTennisplayer(fn, ln)是成员初始化列表
RatedPlayer::RatedPlayer(unsigned int r, const string  & fn, const string  & ln) : TableTennisplayer(fn, ln){
    rating = r;
}
```

公有继承中，派生类不能直接访问基类的私有成员，必须通过基类的方法进行访问。**派生类的构造函数必须使用基类构造函数。**

要点：

* 首先创建基类对象；
* 派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数；
* 派生类构造函数应初始化派生类新增的数据成员。

公有继承是最常用的方式，其派生类对象也是一个基类对象，可以对基类对象执行的任何操作，也可以对派生类对象执行。

### 多态公有继承

希望同一个方法在派生类和基类中的行为是不同的。两种方式可实现：

* 在派生类中重新定义基类的方法；
* 虚方法。

