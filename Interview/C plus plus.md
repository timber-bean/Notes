[TOC]

# 程序从源程序到可执行文件的过程

- 编程
- 编译预处理：处理宏定义，头文件，特殊符号之类的
- **编译**：处理关键字，确认所有指令是否符合语法
- 优化：删除公共表达式，循环优化之类的，优化之后得到汇编程序
- **汇编**：将汇编程序翻译成目标机器指令
- **链接**：将多个目标文件及所需要的库连接成最终的可执行目标文件
  - 静态链接（形成可执行文件前链接，需要副本及浪费空间，执行速度快，更新困难）
  - 动态链接（执行时链接，不会出现副本加载，不会浪费空间，执行速度慢，更新方便）
- 可执行文件

# include头文件

* 顺序
  * 对于include的头文件来说，如果在文件a.h中声明一个在文件b.h中定义的变量，而不引用b.h。那么要在a.c文件中引用b.h文件，并且要先引用b.h，后引用a.h,否则汇报变量类型未声明错误。
* 双引号和尖括号
  * 查找头文件的顺序不同
    * 双引号
      * 当前头文件目录（用户目录）
      * 编译器设置的头文件路径
      * 系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径
    * 尖括号（不会找当前头文件目录）
      * 编译器设置的头文件变量
      * 系统变量指定的路径

# C++11新特性

- 关联容器中的无序容器（unordered_set, unordered_map）
- forword_list（单向链表）
- auto 自动类型推导
- 序列for循环（类似于python的那种 card:cards）
- lambda表达式（匿名函数：\[capture](params)mutable->return-type{function}）
- nullptr（空指针，NULL是宏定义且值为0，而nullptr是关键字）
- 右值引用（将亡值）

# 面向对象编程的三大特性

* 封装：隐藏对象的属性和实现细节——方法和数据，仅对外公开接口，并控制在程序中对属性的访问级别。
* 多态：接口的多种不同实现方式。（用不变的代码实现可变的算法）
  * 静态（编译时）多态：重载，包括**运算符重载**和**函数重载**
  * 动态（运行时）多态：重写，通过**虚函数**实现。
    * 类继承，且继承关系中有虚函数
    * 用父类指针指向子类对象
    * 用父类指针来调用子类对象中的成员函数
* 继承：允许我们依据另一个类来定义一个类。

# STL

* vector
  * 动态数组：为实现动态，编译器会为vector默认生成一个长度，当插入的元素个数大于该长度时，就会生成一个原长度二倍的数组，并将原来的数组数据拷贝到新数组中。**可随机访问，删除效率低**
* list
  * 双向链表：不支持下标访问，插入、删除效率高
* deque
  * 双向队列：可实现双向插入的动态数组。支持下标访问，插入、删除和随机访问的效率是list和vector的折中
* set，multiset
  * 分别实现无重复元素和有重复元素的集合。底层实现：红黑树（自平衡的二叉排序树）
* map，multimap
  * 分别实现一对一和一对多（键值对中的键值可重复）的映射关系。底层实现：红黑树

# STL容器分类

* 关联容器
  * 无序容器：查询效率高：（散列表）unordered_set，unordered_multiset，unordered_map，unordered_multimap
  * 有序容器：有序：（红黑树）set，multiset，map，multimap
* 顺序容器（相对关联而言）
  * string
  * vector
  * list
  * forward_list
  * deque

# 虚函数

* 用virtual关键字说明的函数
* 实现多态的基础
* **注意**
  * 构造函数不能是虚函数
  * 虚析构函数（有子类的父类的析构函数，必须是虚函数）
  * 类的静态成员函数不能是虚函数
  * 内联函数不能是虚函数（内联函数是静态编译，而虚函数是动态调用的）

# 纯虚函数

* 定义：纯虚函数是一种特殊的虚函数，在基类中声明但是不在基类中定义具体操作，如下所示：

```C++
virtual func() = 0;
```

# 虚函数表

* 定义：虚函数表是一个类的虚函数的地址表，每个对象在创建时，都会有一个指针指向该类的虚函数表。
* 作用：在用父类的指针调用子类对象成员函数时，虚函数表会指明要调用的具体函数是哪个。
* 原理：每一个类的虚函数表，按照函数声明的顺序，会将函数地址存在虚函数表中，当子类对象重写父类的虚函数的时候，父类的虚函数表中对应的位置会被子类的虚函数地址覆盖。
* 局限性：当父类的虚函数是非public时，它依然会存在在虚函数表中，所以可以通过虚函数指针来访。

# 抽象类

* 定义：含有纯虚函数的类叫抽象类，若派生类没有重写该纯虚函数，那么该派生类也是抽象类。
* 不能创建抽象类的对象（不能用new），但是可以声明对象指针。

# 智能指针

* shared_ptr，unique_ptr，weak_ptr
  * shared_ptr：多个指针指向相同的对象。大小是原始指针的两倍，因为它内部有一个原始指针指向资源，同时有个指针指向引用计数
  * unique_ptr：唯一拥有所指对象
  * weak_ptr：配合shared_ptr而引入的指针，避免shared_ptr相互指向产生环形结构
* 头文件：memory
* 引用智能指针的作用
  * 程序员不用手动释放资源，方便内存管理
  * 利用了RAII（资源获取即初始化）

# 野指针

* 定义：指向不可用内存的指针
* 形成原因
  * 指针变量没有被初始化
  * 指针所指的内存被释放，但是指针本身没有被置为null
  * 指针超过了变量的作用范围
* 指针悬挂：指向一个已经释放的内存空间

# 指针和引用

* 本质：引用是变量别名，指针是地址
* 安全性：引用安全，指针不安全，用不好会造成内存泄露
* 可空，可变：
  * 指针可以为空，指向的对象可以改变
  * 引用在初始化时确定了引用对象，之后不能再改变
* 空间大小：引用就是原对象的大小；指针大小由计算机决定，32位是4字节，64位是8字节
* 函数传值、引用、指针
  * 传值：对实参创建一份拷贝，在函数中改变这个值，实参原来的不会被改变
  * 传指针：对实参创建一个指针变量，在函数中改变这个值，实参也会被改变
  * 传引用：**没有创建拷贝，没有创建变量**，对实参取别名后，直接对这个量进行更改

# 右值引用

* 左值和右值
  * 右值：没有名字，不能被修改的变量和表达式，只能出现在复制号右边
  * 左值：既可以出现在赋值号左边，也可以出现在赋值号右边的量
  * 左值可以是右值，右值不能是左值
* 左值引用和右值引用
  * 左值引用：使用T&，只能绑定左值
  * 右值引用：使用T&&，只能绑定右值
  * 常量左值，使用const T&，既可以绑定左值又可以绑定右值
  * 已命名的右值引用，编译器会认为是个左值
* **右值引用的好处**
  * 避免无意义的复制、析构
  * 延长右值的声明周期
* **函数返回值用引用的好处**
  * 在内存中可以产生返回值的副本
  * 不能返回局部变量的引用，因为局部变量在函数结束之后就会被销毁

# 大端模式、小端模式

* 大端模式：低字节存储在高位

* 小端模式：低字节存储在低位

* 判断大端模式或小端模式？用union，撰写如下代码。若返回值是0，则是小端模式；若返回值是1，则是大端模式。
  ```C++
  int fun(){
      union test{
          int a;
          char b;
      };
      test t;
      t.a = 1;
      return (t.b==1)
  }
  ```

# overload、override、overwrite

overload（重载）、override（重写）、overwrite（覆盖）的区别。

## overload

在C++程序中，可以将语义、功能相似的几个函数用同一个名字表示，但参数不同（包括数目、类型、顺序不同）。特征：

* 相同的范围（在同一个类中）；
* 函数名字相同；
* 参数（数目、类型、顺序）不同。

## override

是指派生类函数覆盖基类函数，特征是：

* 不同的范围（分别位于派生类与基类）；
* 函数名字相同；
* 参数相同；
* 基类函数必须有virtual关键字（虚函数）。

作用：可根据基类指针**所指向的具体对象**确定调用哪个方法。

## overwrite

是指派生类的函数屏蔽了与其同名的基类函数，规则：

* 如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏。
* 如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。

作用：根据**指针类型**决定用哪个函数，基类指针就用基类的函数，子类指针就用子类的函数。

|           | 函数名 | 参数列表 | virtual | 作用域 |
| :-------: | :----: | :------: | :-----: | :----: |
| overload  |  相同  |   不同   |    /    |  相同  |
| override  |  相同  |   相同   |   有    |  不同  |
| overwrite |  相同  |   相同   |   无    |  不同  |
|           |        |   不同   |  均可   |  不同  |

# 内存分配

![memory1](F:\Notes\Interview\pic\memory1.png)

* 栈：存储局部变量，效率高，操作系统和编译器自动分配
* 堆：malloc分配
  * 自由存储区：new，若程序员忘记释放，在程序结束后，操作系统会自动回收
* 全局/静态存储区：全局变量和静态变量
* 常量存储区：常量，不允许修改
* 自由存储区和堆的区别和联系
  * 区别
    * 自由存储区是C++中通过new/delete动态分配和释放对象的抽象概念
    * 堆是操作系统的概念，是操作系统维护的一段动态分配的内存
  * 联系：在C++中，是用malloc实现的new，物理上，自由存储区属于堆

* 堆和栈
  * 管理方式不同：堆是由程序员管理；栈是由系统管理
  * 碎片问题
    * 堆：频繁的new/malloc会造成大量的内部碎片
    * 栈：先入后出的结构，进出一一对应，不会产生内部碎片
  * 生长方向：堆向上，由低向高生长；栈向下，由高到低生长
  * 分配方式
    * 堆是动态分配，没有静态分配
    * 栈中既有静态分配又有动态分配，静态分配是编译器完成的，动态分配是由malloc函数分配，编译器自动释放，无需程序员实现
  * 空间大小
    * 堆是不连续的内存空间（用链表来存储空闲内存地址），空间大
    * 栈是一块连续的内存空间，空间小

# 内存存储方式

|    存储描述    | 持续性 | 作用域 | 链接性 |          声明方式          |
| :------------: | :----: | :----: | :----: | :------------------------: |
|    自动存储    |  自动  | 代码块 |   无   |         在代码块中         |
|   寄存器存储   |  自动  | 代码块 |   无   |  在代码块中，使用register  |
|  静态，无链接  |  静态  | 代码块 |   无   |   在代码块中，使用static   |
| 静态，内部链接 |  静态  |  文件  |  内部  | 不在任何函数中，使用static |
| 静态，外部链接 |  静态  |  文件  |  外部  |       不在任何函数中       |

# 内存泄露

定义：由于疏忽或错误造成程序**未能释放掉不再使用的内存**的情况。

* 堆内存泄露：如果只malloc，new而在使用完成后没有free，delete。会造成堆内存泄露。
* 系统资源泄露：程序使用系统分配的资源（Socket，handle等）没有使用相应的函数释放掉，导致系统资源的浪费。
* 没有将基类的析构函数定义为虚函数：当基类指针指向子类对象时，子类的析构函数不会被调用，子类的资源没有被正确释放，造成内存泄露。

## 如何处理C++的内存泄露

* 使用varglind，mtrace检测

# 内存溢出

定义：系统中存在**无法回收的内存**或**使用的内存过多**，使得程序运行需要的内存大于系统能提供的内存。

原因：

* 内存中加载的数据量过于庞大（使用的内存过多）
* 集合类中又对对象的引用，并且使用完未清空（无法回收）
* 代码中存在死循环或者循环产生过多重复的对象实体（使用的内存过多）
* 启动参数设定过小
* 第三方软件存在bug

# 栈溢出

* 局部数组过大。因为局部变量存储在栈中。解决：增大栈空间；改用动态分配
* 递归调用层次太多。递归函数在执行时需要压栈，压栈次数太多，会导致栈溢出。
* 指针或数组越界。例如进行字符串拷贝，或处理用户输入等。

# new和malloc

## 联系

* 都是为了解决内存动态分配的问题
* new和delete的底层是用malloc和free实现的
* new先用malloc分配内存，然后调用构造函数
* delete先调用析构函数，然后free释放内存

## 区别

* **本质**：new是运算符，malloc是函数
* 参数：new不需要自己指定申请的内存大小，malloc需要配合sizeof
* 返回类型：new根据对象的类型返回指针，malloc返回值为void*，需要进行强转
* 内存区域：new从自由存储区为对象分配空间，malloc从堆上分配
* 重载：new允许重载，malloc不允许
* 申请失败：new会抛出异常，malloc返回null
* 效率：malloc的效率比new快
* 申请对象：new可以为任意类型申请空间，malloc不能为对象申请空间

## 为什么有了malloc/free还需要new/delete

因为在为对象申请空间时，除了动态内存分配，还需要调用构造函数进行初始化，不能同时把两个工作都交给malloc，所以需要new。

## void*

* 本质：一种不确定类型的指针
* 赋值
  * 它可以赋值给任意类型的指针，不需要强制类型转换
  * 它可以赋值给任意类型的变量，但是需要强制类型转换，且在转换之后就不能转换成其他类型了。

# const

定义：用来限定一个变量是只读，不可变，能提高程序的健壮性

* const和指针（根据const和\*的相对位置区分）
  * 常量指针(const int* p)：指针可指向别人，但是指针指向的值不可变
  * 指针常量(int* const p)：指针不可指向别人，但是指针指向的值可变
* const和函数
  * 修饰类的成员函数：int func()  const：（注意是在后面加const）函数体内不能修改成员变量的值
  * 修饰函数形参：函数体内不能修改形参
  * 修饰返回值：返回值不能修改

