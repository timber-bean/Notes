[TOC]

# OSI七层有哪些

* 物理层：确定机械及电气规范，传输**bit**，主要有IEEE802.3
* 数据链路层：将bit组装成帧，完成**点到点**的传递，传输**帧**，主要有MAC、PPP、HDLC协议
* 网络层：负责数据包的传递和**网际互连**，传输**数据包**，主要有IP、ICMP、ARP协议
* 传输层：提供**端到端**的报文传递，传输**报文**，主要有TCP、UDP协议
* 会话层：建立、管理和终止会话，主要有RPC、NFS协议
* 表示层：对数据进行翻译、加密和压缩，主要有JPEG、ASII协议
* 应用层：通过应用**进程**的交互实现特定网络应用，主要有FTP、HTTP、DNS、SMTP协议

# 浏览器输入url后会发生什么

* 应用层
  * 浏览器分析链接，用**DNS协议**解析服务器ip地址。
  * 首先从本地域名服务器的高速缓存中查询，若查询失败，则依次向根域名服务器、顶级域名服务器、权限域名服务器查询。
* 传输层
  * DNS是基于UDP的，因此会用到UDP协议，而HTTP是基于TCP的，因此需要建立**TCP**连接。
  * HTTP1.0建立非持续的TCP连接，HTTP1.1会建立持续的TCP连接。TCP的端口号一般是80。
* 网络层
  * 需要进行路由选择，选择合适的下一跳ip。如果使用了NAT，则经过NAT路由器时需要进行地址转换。
  * 在内部网关中，需要用到RIP协议（基于距离向量）或者OSPF协议（基于链路状态）。
  * 在外部网关中，需要用到BGP协议。
  * 找到ip地址后，需要使用**ARP**协议，将ip地址解析为MAC地址。（本局域网内广播一个ARP请求分组来查询。）
* 数据链路层
  * 得到MAC地址后，经过交换机自学习功能确定转发端口。
* 物理层
  * 剥离帧的封装，传输比特流。

# HTTP（超文本传输协议）

* HTTP过程
  * 用户输入url/点击超链接
  * 浏览器分析url，向DNS服务器请求解析ip地址
  * 建立TCP连接，在第三次握手时，用户把HTTP请求报文作为第三次报文发送给服务器
  * 释放TCP连接
  
* HTTP状态码
  * 1xx：临时响应，响应码请求被接受，需要继续处理
  * 2xx：请求已被服务器成功接受处理
    * 200：客户端请求成功。
    * 206：服务器已成功处理了部分GET请求。（可应用于迅雷等HTTP下载工具，将一个大文档分解为多个下载段同时下载）
  * 3xx：重定向
    * 301：被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。
    * 304：未改变。客户端发送一个带条件的GET请求且该请求被允许，而请求的文档内容未改变。304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。
  * 4xx：客户端发生错误，服务器无法正常处理
    * 403：拒绝请求。服务器理解客户端请求，但拒绝处理，可能与权限设置有关。
    * 404：未找到。请求所希望得到的资源未被在服务器上发现。
  * 5xx：服务器发生错误
    * 502：无响应网关/代理。上游服务器和网关/代理没有使用统一的协议交换数据。
  
* HTTP请求方法
  * GET：请求读取url标识的信息
  * POST：数据包含在请求体中
  * HEAD：类似于GET请求，返回的响应中没有具体内容，用于获取报头
  
  -------------------------------------------------------------------------------------------------------------------------------
  
  以上是HTTP1.0的三种方法，以下是HTTP1.1新增的六种方法
  
  -------------------------------------------------------------------------------------------------------------------------------
  
  * PUT：从客户端向服务器传送的数据取代指定的文档内容
  * DELETE：请求服务器删除指定页面
  * CONNECT：用于代理服务器
  * OPTIONS：允许客户端查看服务器性能
  * TRACE：回显服务器收到的请求，主要用于测试
  * PATCH：对PUT方法的补充，用来对已知资源进行局部更新
  
* 特点

  * 无状态（无记忆），所以需要cookie
  * 基于TCP：HTTP本身无链接，TCP是基于链接的

# HTTP2.0

在开放互联网上HTTP 2.0将只用于https://网址，而 http://网址将继续使用HTTP/1。

* 多路复用：允许同时通过单一的HTTP/2连接发起**多重**请求-响应信息。单连接多请求的**双向交换**信息。
* 二进制分帧：在应用层和传输层之间增加一个二进制分帧层。
* 首部压缩：使用HPACK算法压缩首部。
* 服务端推送：在客户端请求之前发送数据的机制。服务器可以对客户端的一个请求发送多个响应。

# HTTPS工作过程

* 协商加密算法
  * 客户端A向服务器B发送浏览器的SSL版本号和一些可选的加密算法
  * B从中选择自己支持的算法，告知A
* 服务器鉴别
  * B向A发送包含其共要的证书
  * A使用证书的认证机构CA的公钥验证证书
* 会话密钥计算
  * 由A产生一个随机的秘密数，用B的共要加密并发送给B
  * 双方根据协商的算法产生共享的对称会话密钥
* 双方用会话密钥加解密传送的数据，并验证其完整性

# HTTP和HTTPS的区别

|          |    HTTP     |                  HTTPS                   |
| :------: | :---------: | :--------------------------------------: |
| 传输方式 |    明文     |                 TLS加密                  |
| 连接建立 | TCP三次握手 |        TCP三次握手+SSL的handshake        |
|   证书   |     无      | 服务端需申请证书，客户端需安装对应根证书 |
|   端口   |     80      |                   443                    |

# GET和POST的区别

* GET把参数包含在url中，POST通过request body传递参数
* GET在浏览器回退是无害的，而POST需要再次提交请求
* GET请求会被浏览器主动cache，而POST不会，除非手动设置
* GET请求只能进行url编码，而POST支持多种编码方式
* GET请求参数会被完整的保留在浏览器历史记录里，而POST中的参数不会被保留
* GET请求在url中有长度限制，而POST没有
* GET只接受ASCII字符，而POST可以接受任意字符

# Cookie和Session

由于HTTP是无状态协议，为维持和跟踪用户状态，引入Cookie和Session。Cookie保存了当前用户的登录凭证。攻击者可以不通过密码，而通过获取Cookie来直接登录用户的账户。

* Cookie是钥匙，Session是锁芯。
* Cookie存储在客户端，Session存储在客户端
* Cookie不安全，而Session更安全些。（攻击者可以通过分析存放在本地的Cookie进行Cookie欺骗）
* Session会在一段时间内保存在服务器中。当访问量增多，会影响服务器性能。
* Cookie保存的数据不能超过4K，且一个站点最多保存20个Cookie；Session没有限制

# DHCP协议

* 作用：动态ip地址配置
* 特点
  * 基于UDP（因为DHCP结束之前，主机没有ip地址）
  * 支持地址重用，每个IP地址都有租用期
* 过程
  * 主机广播DHCP**发现报文**：询问是否有DHCP服务器
  * DHCP服务器广播**提供报文**：回复询问
  * 主机广播DHCP请求报文：索要ip地址
  * DHCP服务器广播DHCP确认报文

# TCP和UDP的区别

|          |                     TCP                      |        UDP         |
| :------: | :------------------------------------------: | :----------------: |
|  连接性  |                    有连接                    |       无连接       |
|  可靠性  |                     可靠                     |       不可靠       |
| 传输单位 |                   面向字节                   |      面向报文      |
| 首部开销 |                   20 Byte                    |       8 Byte       |
|   功能   | 分用复用、差错校验、可靠传输、拥塞控制、流控 | 分用复用、差错校验 |

# TCP连接的建立与释放

* 三次握手
  * 连接请求报文不携带数据，但是要消耗一个随机产生的序号x
  * 确认报文不携带数据，同样消耗一个随机产生的序号y
  * 可携带也可不携带数据，不携带数据就不消耗序号，此时连接建立后，第一次发送数据的序号为x+1
* 四次挥手
  * 客户端发起释放请求，请求结束报文不携带数据，但消耗序号
  * 服务器回复确认，客户端到服务器的连接处于半关闭状态，客户端可以接受数据，但不可以发送
  * 服务器发送完数据后，发起释放请求
  * 客户端回复确认，等2MSL（两个最长报文段寿命）后，彻底断开

* 三次握手可能引发什么问题？为什么？
  * 可能引发洪范攻击
  * 因为服务器端的资源是在第二次握手后分配的，而客户端的资源是在第三次握手后分配的，攻击者可以发送大量第一次握手的数据包，而对服务器的回复ACK不予确认，导致服务器所有的连接处于半挂起状态，消耗服务器资源。
* time_wait和close_wait分别出现在哪一方
  * time_wait：主动关闭连接的一方
  * close_wait：被动关闭的一方

* 握手为什么是三次？
  * 因为在第二次握手中，服务器连接建立请求SYN和对客户端的回复ACK是一起发送的。
* 挥手为什么不能是三次？
  * 因为服务器回复客户端ACK时，服务器还有数据要发送给客户端。

# TCP保证可靠的方式

* 校验：目的是检测数据在传输中是否发生了变化
* 序号：保证按序发送，按序到达
* 确认：TCP使用累计确认，确认按序到达的报文段
* 重传
  * 超时重传：如果在计时器时间内，未收到ACK，则重传
  * 快速重传：接收到三个冗余ACK时，重传

# TCP的拥塞控制和流量控制

* 目的不同：拥塞控制控制**量**，流量控制控制**速度**
* 范围不同：拥塞控制面向**整个网络**，流量控制面向**当前连接**
* 任务不同：拥塞控制的任务是**发送方根据四个算法检测网络，不断调整拥塞窗口的大小**；流量控制的任务是**动态修改报文中的窗口字段，及时告知发送方接收窗口大小是多少**。
* 结果相同：最终都是改变了发送窗口（发送窗口=min(拥塞窗口，接受窗口)），从而控制发送方发送数据的速度。

# RIP协议

* 特点
  * 简单，开销小
  * 维护从自己到其他每一个目的网络的最佳距离记录
  * 一个路径最多包含15个路由器，16表示网络不可达（因此只适合小型网络，避免了环路带来的拥塞）
  * 每经过一个路由器，跳数+1，RIP认为最好的路由是通过的路由器最少
  * 好消息传得快，坏消息传得慢（**慢收敛**）

* 与**相邻路由器**交换**自己的路由表**，30s交换一次，若180s没发生交换，就判断链路出问题了，更新距离为16

# OSPF协议

* 特点
  * 运用开放最短路径优先、迪杰斯特拉算法
  * 每30min刷新一次数据库链路状态，收敛速度快
  * 在互联网规模大的时候，OSPF协议比RIP协议快得多
  * 对不同业务，可计算出不同路由，更灵活
* 和谁交换？
  * 洪范法，向所有路由器发送信息
* 交换什么？
  * 相邻所有路由器的链路状态（费用、距离、时延、带宽）
  * 最后所有的路由器都能建立一个链路状态数据库，每个路由器得到一个全网拓扑图，对该图进行迪杰斯特拉最短路径计算，得到最短路由

* 多久交换一次？
  * 30min或链路状态发生变化时

# BGP外部网关协议

* 特点
  * BGP发言人身兼多职，一般是某一个边界路由器，即要运行OSPF/RIP又要运行BGP
  * 只能选择一个较好的路由，选不出最好的
  * 刚开始运行时，与邻站交换整个路由表，以后只在有变化时更新

* 和谁交换？
  * 与其他AS的邻站BGP发言人交换信息

* 交换什么？
  * 网络可达性信息，要达到某个网络要经过的一系列AS

* 何时交换？
  * 发生变化时交换一次

# 划分子网

划分子网的表示方法：IP地址 = {<网络号>，<子网号>，<主机号>}（全0或全1不能作为子网号）

| 类别 |     网络号范围      |   子网掩码    |
| :--: | :-----------------: | :-----------: |
|  A   |        1-126        |   255.0.0.0   |
|  B   |    128.1-191.255    |  255.255.0.0  |
|  C   | 192.0.1-223.255.255 | 255.255.255.0 |

