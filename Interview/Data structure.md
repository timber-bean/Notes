[TOC]

# 线性表

## 数组和链表的区别

* 从结构上：数组和链表都是线性结构。但是，数组是一块**连续**的内存空间；链表可以是**离散**的内存空间，用指针连接
* 从操作上：数组能够实现按下标**访问**和**修改**，查找效率高，链表的查找效率低；数组的**增加**和**删除**需要移动元素，效率低，但是链表的增加和删除只需要修改指针，在o(1)时间内就能完成
* 从存储上：静态数组从栈上开辟空间，链表从堆上开辟空间

## 链表种类

单链表、双链表、循环链表、静态链表

## 队列

- 顺序结构：用取模运算将静态数组在逻辑上变为环状
- 链式结构：带头结点的单链表，front指针指向收元素，rear指针指向尾元素的下一个位置
- 双端队列

## 循环队列如何区分队空和队满

- 牺牲一个存储单元
- 增加成员size
- 增加成员tag

## 队列的应用

- 树的层次遍历
- 图的广度搜索
- 缓冲区：解决主机和外部设备之间速度不匹配问题

# 树

## 度为m树与m叉树的区别和联系

- 相同点：任意结点的度不得超过m
- 不同点：
  - 度为m的树：至少有一个结点的度为m，整棵树最少有m+1个结点
  - m叉树：允许所有的结点的度都少于m，可以是空树

## 特殊二叉树有哪些

- 满二叉树：顾名思义
- 完全二叉树：结点顺序和满二叉树一样，但是不一定满
- 二叉排序树：左（右）子树上的所有节点的关键字均小于（大于）根节点
- 平衡二叉树：在二叉排序树的基础上，左右子树深度之差不超过1

## 二叉树的遍历方式

* 前序遍历：根左右
* 中序遍历：左根右
* 后序遍历：左右根

## 由遍历序列构造二叉树

- 由遍历序列可以确定唯一二叉树的情况：前序+中序；后序+中序；层次+中序（一定要有中序）
- 前序序列和后序序列可以确定任意两个结点直接的父子关系

## 平衡二叉树

* 调整不平衡
  * LL：在左孩子的左子树中插入：向右直接转动一次不平衡节点
  * RR：在右孩子的右子树中插入：向左直接转动一次不平衡节点
  * RL：在右孩子的左子树中插入：先向右转一次不平衡结点的孩子，再向左转一次不平衡节点
  * LR：在左孩子的右子树中插入：先向左转一次不平衡结点的孩子，再向右转一次不平衡节点

* 平衡二叉树与二叉排序数的区别和联系
  * 平衡二叉树是在二叉排序树的基础上，再增加平衡的条件
  * 二叉排序树插入新节点，该节点一定会成为叶子结点
  * 平衡二叉树插入新节点，该节点不一定是叶子结点（因为导致不平衡之后还会调整）

## 红黑树

红黑树是一种弱平衡树，相对于AVL来说，旋转次数少，查询、插入和删除操作的时间复杂度都是O(logN)，且性能稳定，因此C++的STL中的很多结构都是用红黑树实现的。

* 性质：
  * 每个节点非黑即红
  * 根节点是黑色的
  * 每个叶子节点都是黑色的
  * 如果一个节点是红色的，则它的子节点必须是黑色的
  * 对于任意节点，其到叶子节点的每条路径都包含相同数目的黑节点
* 与AVL的区别
  * AVL是高度平衡的，频繁的插入与删除，会引起频繁的rebalance，导致效率下降
  * 红黑树不是高度平衡的，插入最多旋转两次，删除最多旋转三次

# 排序

**堆排序**

基本思想：将待排序序列构造成一个大顶堆，首尾交换，末尾元素是最大值，再调整剩余堆元素，直到排序完成。

* 先从左到右、从下至上的构建大顶堆
* 将堆顶元素与末尾元素交换，末尾元素即是最大值
* 调整除末尾元素的大顶堆（方向是从上到下）

时间复杂度：O(N logN)

**快速排序**

基本思想：分治。

* 选一个基准值
* 把小于基准值的放在前面，大于基准值的放在后面，比较完成，基准值位列数组中间
* 递归地把基准值前的子数列和基准值后的子数列同理排序

时间复杂度：O(N logN)

**归并排序**

基本思想：分治。

* 先把数列拆分，直至单个元素为止
* 二路归并，直至排序完成

时间复杂度：O(N logN)

# 查找

* 顺序查找：从头到尾依次遍历

* 折半查找
  * 待查找的序列必须有序
  * 必须顺序存储
  * 平均查找长度：ASL = log2(n+1) – 1

* 分块查找：块间有序，块内无序。现在索引表搜索分块，再在块内顺序查找

* 散列表
  * 处理冲突的方法：
    * 拉链法：所有同义元素放在一个单链表中
    * 开放地址法
      * 线性探测法：易造成同义元素聚集现象
      * 平方探测法
      * 再散列法：使用多个哈希函数
      * 伪随机序列法：冲突时地址加上一个随机数构造新地址


# B树与B+树

|      B树（多路平衡查找树，也叫B-树）       |                   B+树                   |
| :----------------------------------------: | :--------------------------------------: |
|      由二叉查找树进化而来-->m叉查找树      |    由分块查找进化而来-->多级分块查找     |
|        根节点的关键字范围：[1，m-1]        |        根节点的关键字范围：[2，m]        |
|           n个关键字对应n+1个分支           |           n个关键字对应n个分支           |
|        **所有节点**中都包含记录信息        |       **只有叶节点**中包含记录信息       |
|               不支持顺序查找               |               支持顺序查找               |
| 查找结束时可能停在任意节点，查找速度不稳定 | 查找结束时只能停在叶子节点，查找速度稳定 |
|            应用：文件系统的查找            |    应用：关系型数据库的索引（mysql）     |

| 关于分支是一样的：根节点分支数范围：[2，m]；除根节点外，其他节点数范围：[m/2，m] |
| ------------------------------------------------------------ |
| 插入删除原则：每个节点内部有序，树始终平衡，满足关键字个数和分支个数要求 |

* B树的查找：层间折半查找，节点内顺序查找。

* B树的插入

  * 用查找确定插入位置
  * 若插入导致关键字数超过上限：从中间位置分裂成两个部分，右边部分放在新节点中，左边部分放在原节点中，中点位置插入原节点的父节点中。新元素一定是插入到最底层的终端节点，用查找来确定插入位置
  * 若进一步导致父节点的关键字也超过上限：左右划分，继续向上分裂成新的节点，直到根节点

* B树的删除

  * 若被删除的关键字在终端节点：删除后关键字个数未低于下限，直接删除；低于下限，从左右兄弟那借
  * 若删除的关键字在非终端节点：一定可以转化为终端结点删除，用直接前驱或者直接后继来替代被删除的关键字，随后删除这个直接前驱或者直接后继

* B+树的插入

  * 总是插入在叶节点
  * 当叶节点中关键字值数大于上限时，该节点分裂，分别使关键字值的个数为(m+1)/2向上取整，且双亲结点必须包括这两个节点的最大关键字值

* B+树的删除

  * 只在叶节点中删除关键字值
  * 当叶节点中最大关键字值被删除时，分支节点中的关键字值可以作为“分界关键字值”存在
  * 若使得节点中的关键字值小于m/2向上取整时，则要与兄弟节点合并

## 为什么MySQL数据库索引使用B+树？

MySQL中的MylsAM和InnoDB引擎，都是采用B+树结构。前者是非聚集索引（B+数的数据域存储的是数据地址），后者主键是聚集索引（B+数的数据域存储的就是真实数据）。

* **B+树的磁盘读写代价更低**。内部节点**只有关键字（key）**，使得每次从文件中读取的索引更多，减少IO读写次数。
* **B+树的查询效率更稳定**。因为只有叶子节点存储记录信息，因此所有关键字查询的路径长度一样，必须查询到叶子节点。
* **B+树的数据都存储在叶子节点中，方便扫库**。因为只有叶子节点存储记录信息，因此更适合区间查询。

# 串

## 模式匹配（KMP算法）

核心思想：构造next数组，使得**旧的后缀要和新的前缀保持一致**，进而只移动模式串，不移动主串。

规定：如果在模式串的第n个字符匹配失败了，则取next[n-2]的数作为模式串匹配的序号指针，继续与主串匹配。

例子：

​	模式串：abaabac

​	则next[0] = 0（默认），next[1] = 0，next[2] = 1，next[3] = 1，next[4] = 2，next[5] = 2，next[6] = 3，next[7] = 4

​	{ next[4]是因为'a'和'a'相同，所以若第4个字符比较失败，则移动模式串的第2个字符继续比较；next[6]是因为'ab'和'ab'相同，所以若第6个字符比较失败，则移动模式串的第3个字符继续比较}





